"""ATG - Main module.

This module contains the main entry point for the ATG (Automated Test Generator) tool.
"""
import argparse
import json
import logging
import sys
from pathlib import Path
from typing import Optional, Sequence, Dict, Any

from atg.ai import TestGenerator
from atg.config import config
from atg.ingestion import get_parser_for_file

logger = logging.getLogger(__name__)


def parse_args(args: Optional[Sequence[str]] = None) -> argparse.Namespace:
    """Parse command line arguments.

    Args:
        args: Command line arguments. If None, uses sys.argv[1:].

    Returns:
        Parsed arguments.
    """
    parser = argparse.ArgumentParser(
        description="ATG - Automated Test Generator",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # Logging and output
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="Increase verbosity (can be used multiple times)",
    )
    parser.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        help="Suppress non-essential output",
    )

    # Input/output
    parser.add_argument(
        "source",
        type=Path,
        help="Source file or directory to generate tests for",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        default=Path("tests"),
        help="Output directory for generated tests",
    )

    # AI configuration
    parser.add_argument(
        "--model",
        type=str,
        default=config.get("model_name"),
        help=f"AI model to use (default: {config.get('model_name')})",
    )
    parser.add_argument(
        "--temperature",
        type=float,
        default=config.get("temperature"),
        help=f"AI temperature (0.0 to 1.0, default: {config.get('temperature')})",
    )
    parser.add_argument(
        "--framework",
        type=str,
        default=config.get("test_framework"),
        choices=["pytest", "unittest", "robot"],
        help=f"Test framework to generate (default: {config.get('test_framework')})",
    )

    # Version
    parser.add_argument(
        "-V",
        "--version",
        action="version",
        version=f"%(prog)s {__import__(__package__).__version__}",
    )

    return parser.parse_args(args)


def setup_logging(verbosity: int = 0) -> None:
    """Set up logging configuration.

    Args:
        verbosity: Verbosity level (0=WARNING, 1=INFO, 2=DEBUG)
    """
    level = max(3 - verbosity, 0) * 10  # Convert to logging level
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[logging.StreamHandler()],
    )


def process_file(
    file_path: Path,
    output_dir: Path,
    generator: TestGenerator,
    test_framework: str = "pytest",
) -> Dict[str, Any]:
    """Process a single file and generate tests.

    Args:
        file_path: Path to the file to process.
        output_dir: Directory to save generated tests.
        generator: Initialized TestGenerator instance.
        test_framework: Test framework to generate tests for.

    Returns:
        Dictionary with processing results.
    """
    logger.info(f"Processing file: {file_path}")

    # Get the appropriate parser for the file
    parser = get_parser_for_file(file_path)
    if not parser:
        logger.warning(f"No parser found for file: {file_path}")
        return {"status": "error", "message": f"No parser found for {file_path.suffix}"}

    try:
        # Parse the file content
        content = parser.parse(file_path)

        # Generate test cases using AI
        test_cases = generator.generate_test_cases(content, test_framework)

        # Generate output filename
        test_filename = f"test_{file_path.stem}.py"
        output_path = output_dir / test_filename

        # Save generated tests
        with open(output_path, "w", encoding="utf-8") as f:
            f.write("# Generated by ATG - Automated Test Generator\n")
            f.write("# Source: " + str(file_path) + "\n\n")
            for test_case in test_cases:
                f.write(test_case["content"] + "\n\n")

        logger.info(f"Generated tests saved to: {output_path}")
        return {
            "status": "success",
            "file": str(file_path),
            "test_file": str(output_path),
            "test_cases": len(test_cases),
        }
    except Exception as e:
        logger.error(f"Error processing {file_path}: {str(e)}", exc_info=True)
        return {"status": "error", "file": str(file_path), "message": str(e)}


def main(args: Optional[Sequence[str]] = None) -> int:
    """Run the main application.

    Args:
        args: Command line arguments. If None, uses sys.argv[1:].

    Returns:
        Exit code (0 for success, non-zero for error).
    """
    try:
        parsed_args = parse_args(args)
        setup_logging(0 if parsed_args.quiet else parsed_args.verbose)

        if not parsed_args.quiet:
            logger.info("Starting ATG - Automated Test Generator")
            logger.info(f"Source: {parsed_args.source}")
            logger.info(f"Output directory: {parsed_args.output.absolute()}")
            logger.info(
                f"Using model: {parsed_args.model} (temperature: {parsed_args.temperature})"
            )
            logger.info(f"Test framework: {parsed_args.framework}")

        # Ensure source exists
        if not parsed_args.source.exists():
            logger.error(f"Source not found: {parsed_args.source}")
            return 1

        # Create output directory if it doesn't exist
        parsed_args.output.mkdir(parents=True, exist_ok=True)

        # Initialize AI test generator
        try:
            generator = TestGenerator(
                model_name=parsed_args.model, temperature=parsed_args.temperature
            )
            generator.initialize()
        except Exception as e:
            logger.error(f"Failed to initialize AI test generator: {str(e)}")
            return 1

        results = {"processed": [], "errors": []}

        # Process single file
        if parsed_args.source.is_file():
            result = process_file(
                parsed_args.source, parsed_args.output, generator, parsed_args.framework
            )
            if result["status"] == "success":
                results["processed"].append(result)
            else:
                results["errors"].append(result)

        # Process directory
        elif parsed_args.source.is_dir():
            # Find all supported files in directory
            supported_extensions = [".py", ".md", ".txt", ".pdf", ".docx"]
            for ext in supported_extensions:
                for file_path in parsed_args.source.glob(f"**/*{ext}"):
                    if not file_path.is_file():
                        continue

                    result = process_file(
                        file_path, parsed_args.output, generator, parsed_args.framework
                    )

                    if result["status"] == "success":
                        results["processed"].append(result)
                    else:
                        results["errors"].append(result)

        # Save results summary
        summary = {
            "total_processed": len(results["processed"]),
            "total_errors": len(results["errors"]),
            "processed_files": [r["file"] for r in results["processed"]],
            "error_files": [
                {"file": r["file"], "error": r["message"]} for r in results["errors"]
            ],
        }

        # Save summary to JSON file
        summary_path = parsed_args.output / "test_generation_summary.json"
        with open(summary_path, "w", encoding="utf-8") as f:
            json.dump(summary, f, indent=2)

        if not parsed_args.quiet:
            logger.info("\n=== Test Generation Summary ===")
            logger.info(f"Processed files: {summary['total_processed']}")
            logger.info(f"Files with errors: {summary['total_errors']}")
            logger.info(f"Summary saved to: {summary_path}")

            if summary["total_processed"] > 0:
                logger.info("\nSuccessfully processed files:")
                for file in summary["processed_files"]:
                    logger.info(f"  - {file}")

            if summary["total_errors"] > 0:
                logger.warning("\nFiles with errors:")
                for error in summary["error_files"]:
                    logger.warning(f"  - {error['file']}: {error['error']}")

        return 0 if summary["total_errors"] == 0 else 1

    except Exception as e:
        logger.error(f"An error occurred: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    sys.exit(main())
